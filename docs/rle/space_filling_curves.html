<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  
  
  <link rel="shortcut icon" href="../img/favicon.ico">
<title>Voxel Compression</title>

  <link rel="stylesheet" href="../css/theme.css" />
  <link rel="stylesheet" href="../css/theme_extra.css" />
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" />
  <link href="../css/darcula.css" rel="stylesheet" />
  <link href="../css/extra.css" rel="stylesheet" />
  
  <script>
    // Current page data
    var mkdocs_page_name = "Space-Filling Curves";
    var mkdocs_page_input_path = "rle/space_filling_curves.md";
    var mkdocs_page_url = null;
  </script>
  
  <script src="../js/jquery-2.1.1.min.js" defer></script>
  <script src="../js/modernizr-2.8.3.min.js" defer></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/languages/asm.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/languages/ebnf.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/languages/cpp.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/languages/rust.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/languages/python.min.js"></script>
  <script>hljs.initHighlightingOnLoad();</script> 
  
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
    <div class="wy-side-scroll">
      <div class="wy-side-nav-search">
        <a href=".." class="icon icon-home"> VOXEL COMPRESSION</a>
        <div role="search">
  <form id ="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" title="Type search term here" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../index.html">Compression of Voxel Models</a>
                    </li>
                </ul>
                <p class="caption"><span class="caption-text">Basics</span></p>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../properties.html">Properties of Voxel Models</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../statistical_tests.html">Statistical Tests to Determine Voxel Model Properties</a>
                    </li>
                </ul>
                <p class="caption"><span class="caption-text">Related Work</span></p>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../related/overview.html">Overview over Related Work</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../related/voxel_formats.html">List of Voxel File Formats</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../related/literature.html">References</a>
                    </li>
                </ul>
                <p class="caption"><span class="caption-text">Geometry Encoding</span></p>
                <ul class="current">
                    <li class="toctree-l1"><a class="reference internal" href="../uncompressed.html">Uncompressed Format</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="rle.html">Run-Length Encoding</a>
                    </li>
                    <li class="toctree-l1 current"><a class="reference internal current" href="space_filling_curves.html">Space-Filling Curves</a>
    <ul class="current">
    <li class="toctree-l2"><a class="reference internal" href="#motivation">Motivation</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#comparison-of-space-filling-curves">Comparison of Space-Filling Curves</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#impact-on-run-length-encoding">Impact on Run-Length Encoding</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#summary">Summary</a>
    </li>
    </ul>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="hilbert_curves.html">3D Hilbert Curves</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../svo/svo.html">Sparse Voxel Octree</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../svo/construction.html">SVO Construction</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../svo/optimization.html">SVO Optimization</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../dag/dag.html">Directed Acyclic Graph</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../cuboid_extraction.html">Cuboid Extraction</a>
                    </li>
                </ul>
                <p class="caption"><span class="caption-text">Attribute Encoding</span></p>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../attribute_compression.html">SVO Attribute Compression</a>
                    </li>
                </ul>
                <p class="caption"><span class="caption-text">Implementation</span></p>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../flvc/flvc.html">Free Lossless Voxel Compression (FLVC)</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../flvc/flvc_optimizations.html">FLVC Data Stream</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../flvc/full_example.html">Full Example</a>
                    </li>
                </ul>
                <p class="caption"><span class="caption-text">Auxiliary File Formats</span></p>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../file_formats/vl32.html">32-Bit Voxel List (VL32)</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../file_formats/vlascii.html">ASCII Voxel List (VLASCII)</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../file_formats/structlang.html">Structure Language (StructLang)</a>
                    </li>
                </ul>
      </div>
    </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="..">VOXEL COMPRESSION</a>
      </nav>

      
      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="..">Docs</a> &raquo;</li>
    
      
        
          <li>Geometry Encoding &raquo;</li>
        
      
    
    <li>Space-Filling Curves</li>
    <li class="wy-breadcrumbs-aside">
      
    </li>
  </ul>
  
  <hr/>
</div>
          <div role="main">
            <div class="section">
              
                <h1 id="space-filling-curves">Space-Filling Curves</h1>
<p>A space-filling curve is a curve which's range contains the entirety of a hypercube.
When filling space with a curve, we are generally applying a bijective function:</p>
<p>
<script type="math/tex; mode=display">c: \mathbb{N} \rightarrow \mathbb{Z}^N,\; N \in \mathbb{N}</script>
</p>
<p>This maps discrete points of the curve onto points in (hyper)space.
Note that often times it may be easier to iterate over all points in space and assign an index to each instead.
Since our mapping is bijective, this is also a viable strategy for filling space, as long as we are working within
finite boundaries.
In such a case, we are applying the inverse function:</p>
<p>
<script type="math/tex; mode=display">c^{-1}: \mathbb{Z}^N \rightarrow \mathbb{N},\; N \in \mathbb{N}</script>
</p>
<p>For the sake of simplicity, we will only be discussing three-dimensional space-filling curves
<script type="math/tex">c:\mathbb{N} \rightarrow \mathbb{Z}^3</script>
</p>
<h2 id="motivation">Motivation</h2>
<p>In the previous <a href="rle.html">RLE</a> methods, we have filled space using nested iteration.
Using alternative space-filling curves improves spatial locality over nested iterations.
This is expected to improve the compression ratio of RLE.</p>
<h2 id="comparison-of-space-filling-curves">Comparison of Space-Filling Curves</h2>
<p>We will be discussing three approaches, namely <em>nested iteration</em>, <em>Z-Order Curves</em>, and <em>Hilbert Curves</em> for use in RLE.
First, we introduce, define and present an implementation of all three methods.
Then, we compare them.</p>
<p>One of the points of comparison is how frequently a <em>jump</em> is found in the curve.
The set of jumps <script type="math/tex">J(c)</script> for a curve <script type="math/tex">c</script> is defined as:
<script type="math/tex; mode=display">J(c) = \{(i,j) \in \mathbb{N}\times\mathbb{N} \;\big|\; \lVert c(j) - c(i)\rVert \gt 1\}</script>
The only curves without jumps are curves of which all points are direct neighbors.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>There are many more possible space-filling curves.
Just by permuting coordinates we could obtain six variations of each of our curves.
The three chosen examples were selected because they have significant advantages and disadvantages over one-another
and thus act as a good proxy for comparison of all space-filling curves.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Z-Order Curves are also known as <em>Lebesgue curve</em>, <em>Morton Space-Filling Curve</em>, <em>Morton Order</em> or <em>Morton code</em>.</p>
</div>
<h3>Nested Iteration</h3>
<p><img alt="Nested Iteration" src="../img/nested_iter.svg" /><br>
<em>Figure 1: Nested Iteration in Two Dimensions</em></p>
<p>Let <script type="math/tex">l_x, l_y, l_z \in \mathbb{N}</script> be the dimensions of the volume to fill.
Our curve can be defined as:
<script type="math/tex; mode=display">c(i) = \begin{pmatrix}
i \bmod (l_x \cdot l_y) \cr
\lfloor\frac{i}{l_x}\rfloor \bmod l_y \cr
\lfloor\frac{i}{l_x \cdot l_y}\rfloor
\end{pmatrix}</script>
</p>
<p>It is however much simpler to perform the inverse mapping:
<script type="math/tex; mode=display">c^{-1}(x, y, z) = x + (y \cdot l_x) + (z \cdot l_x \cdot l_y)</script>
</p>
<p>For a cube with dimensions which are powers of two, this is equivalent to concatenating the bits of <script type="math/tex">x</script>, <script type="math/tex">y</script> and <script type="math/tex">z</script>
of any point.
Nested iteration fills space by iterating over all coordinates, with <script type="math/tex">x</script> running the fastest, followed by
progressively slower-running coordinates.</p>
<p>The reverse-approach can be performed without any multiplication at all, using the following code:</p>
<pre><code class="language-cpp">voxel container[limit_x * limit_y * limit_z];
size_t index = 0;
for (unsigned z = 0; z &lt; limit_z; ++z)
    for (unsigned y = 0; y &lt; limit_y; ++y)
        for (unsigned x = 0; x &lt; limit_x; ++x, ++index)
            container[index] = voxel_at(x, y, z);
</code></pre>
<p>Notice how our container can have any shape, it is not limited to a hypercube.
A <em>jump</em> occurs once every <code>limit_x</code> coordinates, where <code>x</code> jumps from <code>limit_x - 1</code> to <code>0</code>.</p>
<h3>Z-Order Curves</h3>
<p><img alt="Nested Iteration" src="../img/z_order.svg" /><br>
<em>Figure 2: Z-Order Curve in Two Dimensions</em></p>
<p>Z-Order Curves have already been presented as a possible solution
<a href="../related/literature.html#a-computer-oriented-geodetic-data-base-and-a-new-technique-in-file-sequencing">in 1996 by G.H. Morton</a>.
They have the significant advantage of a higher spatial locality.
Z-Order Curves can be constructed iteratively by repeating the <em>z-pattern</em> each 2<sup>N</sup> iterations, recursively.</p>
<p>For three dimension, they can be defined as follows:
<script type="math/tex; mode=display">\begin{align}
c(i) &= \text{deinterleave}_3(i) \\
c^{-1}(x, y, z)  &= \text{interleave}_3(x, y, z)
\end{align}</script>
</p>
<p>The operations <script type="math/tex">\text{interleave}_3</script> and <script type="math/tex">\text{deinterleave}_3</script> are the basis for
<a href="../svo/construction.html#octree-node-index">Octree Node Indices</a>.
They (de)interleave the bits of the three coordinates, producing a single index which consists of a series of
octal digits.
See the linked section for an efficient implementation and thorough explanation.</p>
<p>The space-filling itself can be implemented very similarly to nested iteration.
We can implemented Z-Order Curves as follows:</p>
<pre><code class="language-cpp">voxel container[limit * limit * limit];
for (unsigned z = 0; z &lt; limit; ++z)
    for (unsigned y = 0; y &lt; limit; ++y)
        for (unsigned x = 0; x &lt; limit; ++x)
            container[interleave3(x, y, z)] = voxel_at(x, y, z);
</code></pre>
<p>Note that our container now needs to be a cube and also must have dimensions which are a power of two.</p>
<p>Interleaving bits is still the most expensive arithmetic operation performed here.
A typical implementation will interleave each coordinate with zeros first, then combine these partial results using a
bitwise OR.
Only <code>x</code> changes every iteration, so we can cache the results for <code>y</code> and <code>z</code>.
We can perform fewer operations in total using the following code:</p>
<pre><code class="language-cpp">voxel container[limit_x * limit_y * limit_z];
size_t index = 0;
for (unsigned z = 0; z &lt; limit_z; ++z) {
    // assuming this is implemented as a special case which handles zero-inputs
    unsigned zi = interleave3(z, 0, 0);
    for (unsigned y = 0; y &lt; limit_y; ++y) {
        unsigned yi = interleave3(0, y, 0);
        for (unsigned x = 0; x &lt; limit_x; ++x, ++index) {
            unsigned xi = interleave3(0, 0, x);
            container[zi | yi | xi] = voxel_at(x, y, z);
        }
    }
}
</code></pre>
<h3>Hilbert Curves</h3>
<p><img alt="2D Hilbert" src="../img/hilbert.svg" /><br>
<em>Figure 3: Hilbert Curve in Two Dimensions</em></p>
<p>Hilbert Curves also improve spatial locality similar to Z-Order curves.
They are very similar to <em>Z-Order Curves</em> in the aspect that they also have a pattern for each 4 pixels (or 8 voxels)
which is repeated recursively to construct the curve.
However, Hilbert curves also require these units to be rotated depending on their position in the grid at a higher
level.
Despite that, we can construct Hilbert curves from <em>Z-Order Curves</em>.
An efficient implementation of this
<a href="http://and-what-happened.blogspot.com/2011/08/fast-2d-and-3d-hilbert-curves-and.html">was provided by <em>Icabod</em></a>.</p>
<p><img alt="3D Hilbert" src="../img/hilbert3d.gif" /><br>
<em>Figure 4: A Hilbert Curve in Three Dimension - Michael Trott, in The Mathematica GuideBook for Programming</em></p>
<p>The implementation builds on our approach for Z-Order Curves.
It can also be optimized by caching portions of our Morton (Z-Order) index, but the final conversion to our Hilbert
index must happen in its entirety every iteration.</p>
<pre><code class="language-cpp">voxel container[limit * limit * limit];
for (unsigned z = 0; z &lt; limit; ++z) {
    for (unsigned y = 0; y &lt; limit; ++y) {
        for (unsigned x = 0; x &lt; limit; ++x) {
            unsigned morton_index = interleave3(x, y, z);
            unsigned hilbert_index = morton_to_hilbert3d(morton_index);
            container[hilbert_index] = voxel_at(x, y, z);
        }
    }
}
</code></pre>
<h3>Comparisons</h3>
<table>
<thead>
<tr>
<th></th>
<th>Nested Iteration</th>
<th>Z-Order Curve</th>
<th>Hilbert Curve</th>
</tr>
</thead>
<tbody>
<tr>
<td>Complexity per Voxel</td>
<td>
<script type="math/tex">O(1)</script>
</td>
<td>
<script type="math/tex">O(\log{b})</script>
</td>
<td>
<script type="math/tex">O(b)</script>
</td>
</tr>
<tr>
<td>Container Restrictions</td>
<td></td>
<td>cube with dims. 2<sup>n</sup></td>
<td>cube with dims. 2<sup>n</sup></td>
</tr>
<tr>
<td>Jumps</td>
<td>each <script type="math/tex">l_x</script> iterations</td>
<td>each 2 iterations</td>
<td>never</td>
</tr>
<tr>
<td>Implementation Effort</td>
<td>low</td>
<td>medium</td>
<td>high</td>
</tr>
</tbody>
</table>
<p>Z-Order Curves have logarithmic complexity.
However, hardware may support bit-(de)interleaving via a dedicated instruction which can be implemented very easily
by rewiring bits.
This can effectively turn the complexity to <script type="math/tex">O(1)</script>, should such hardware support exist.</p>
<p>Also note that while Z-Order curves have very frequent jumps, the most frequents ones (each 2 iterations) are
short, 2D-diagonal jumps covering a distance of <script type="math/tex">\sqrt{2}</script>.
Each 4 iterations, there is a longer 3D-diagonal jump of <script type="math/tex">\sqrt{3}</script>.
Each 8 iterations, there is an even longer jump, and so forth.</p>
<p>Unlike the simple <code>interleave3</code> operation for Z-Order curves, we can not easily hardware-optimize <code>morton_to_hilbert3d</code>.
Each computed octal digit affects the transformation applied to less significant digits.
This recursive dependency leads to a complexity of <script type="math/tex">O(b)</script>
</p>
<h2 id="impact-on-run-length-encoding">Impact on Run-Length Encoding</h2>
<p>The impact on RLE can be very positive or very negative depending on the used method.
In the following table, we compare how our geometry compression methods are affected by the different curves:</p>
<table>
<thead>
<tr>
<th>Method\Size For</th>
<th>Nested Iteration</th>
<th>Z-Order Curve</th>
<th>Hilbert Curve</th>
</tr>
</thead>
<tbody>
<tr>
<td>Binvox</td>
<td>177 KB</td>
<td>258 KB</td>
<td>184 KB</td>
</tr>
<tr>
<td>Compact Binvox</td>
<td>89 KB</td>
<td>134 KB</td>
<td>98 KB</td>
</tr>
<tr>
<td>Complete Binvox</td>
<td>254 KB</td>
<td>123 KB</td>
<td>109 KB</td>
</tr>
<tr>
<td>In-Band</td>
<td>185 KB</td>
<td>93 KB</td>
<td>77 KB</td>
</tr>
</tbody>
</table>
<p>The surprising effect is that for our bitwise formats <em>Binvox</em> and <em>Compact Binvox</em>, the effect is negative.
For byte-based formats like <em>Complete Binvox</em> and <em>In-Band</em>, the effect is positive.</p>
<h3>Negative Impact on Bitwise Formats</h3>
<p>The reason why bitwise formats are negatively impacted by higher spatial locality is that they rarely profit from
its advantages but are very negatively impacted by its disadvantages.
The main disadvantage which is a potentially higher <em>transition rate</em> is explained as follows:</p>
<p>For bitwise, out-of-band RLE formats, it is possible to determine number of encoded markers using only the number of
transitions <script type="math/tex">t</script> and the number of bits in the stream <script type="math/tex">b</script> (assuming, there is no size limit for the count stored in a
marker).
A transition occurs when a one-bit is followed by a zero-bit or a zero-bit is followed by a one-bit.
When we run-length-encode a bitstream, we only need to encode a new marker for a transition.
If all bits were equal, we would only need to encode a single marker storing the size of the bitstream and the value
of said bit.</p>
<p>Let <script type="math/tex">t</script> be the number of transitions and <script type="math/tex">b</script> the total number of bits in a stream.
The <em>transition rate</em> is <script type="math/tex">t_r = \frac{t}{b}</script> and the average run length <script type="math/tex">r_\oslash  = t_r^{-1} = \frac{b}{t}</script>.
We see the following results for our curves when iterating over our <em>Perlin128</em> model:</p>
<table>
<thead>
<tr>
<th>Stat\Method</th>
<th>Nested Iteration</th>
<th>Z-Order Curve</th>
<th>Hilbert Curve</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<script type="math/tex">t</script> (lower is better)</td>
<td>88936</td>
<td>125046</td>
<td>88410</td>
</tr>
<tr>
<td>
<script type="math/tex">t_r</script> (lower is better)</td>
<td>0.042</td>
<td>0.0601</td>
<td>0.042</td>
</tr>
<tr>
<td>
<script type="math/tex">r_\oslash</script> (higher is better)</td>
<td>23.58</td>
<td>16.64</td>
<td>23.72</td>
</tr>
</tbody>
</table>
<p>The transition rate is very negatively impacted by Z-Order Curves.
This happens because the very frequent jumps which occur in Z-Order Curves will produce significant amounts of
transitions from inside a shape (1) to outside a shape(0) at its boundaries.</p>
<p>Note that Hilbert Curves have a lower transition rate <strong>but still</strong> negatively impact our bitwise formats.
This only happens because with Hilbert Curves, we run out of space in our one-markers
(8 bits for <em>Binvox</em>, 7 bits for <em>Compact Binvox</em>) more frequently due to how efficient this reordering is.
So ironically, better is worse in this case.</p>
<h3>Positive Impact on Bytewise Formats</h3>
<p>In the previous section, I mentioned that bitwise formats rarely profit from the advantages of spatial locality.
Bytewise formats do profit and perform much better as a result.</p>
<p>The primary effect of higher spatial locality is a "clumping" of transitions.
While the number of transitions <script type="math/tex">t</script> may not be affected, sections of our model with more transitions will be placed
closer together and sections with fewer transitions will also be placed together.
This is reflected by another stat, the <em>transition follow-up rate</em> <script type="math/tex">t_f</script>, defined as follows:
<script type="math/tex; mode=display">\begin{align}
\text{is_transition}(i) &= (\text{voxel_exists}(c(i)) \ne \text{voxel_exists}(c(i - 1))) \\
\text{is_follow_up_transition}(i) &= \text{is_transition}(i) \land \text{is_transition}(i-1) \\
t_f &= \frac{\lvert\{0 \le i \lt b | \text{is_follow_up_transition}(i)\}\rvert}{t}
\end{align}</script>
In other words: the probability that a transition is followed-up by another transition.</p>
<p>Here the results for our <em>Perlin128</em> model:</p>
<table>
<thead>
<tr>
<th>Stat\Method</th>
<th>Nested Iteration</th>
<th>Z-Order Curve</th>
<th>Hilbert Curve</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<script type="math/tex">t_f</script> (higher is better)</td>
<td>0.01402</td>
<td>0.4346</td>
<td>0.2885</td>
</tr>
</tbody>
</table>
<p>Bytewise formats do profit from a higher <script type="math/tex">t_f</script>, for a constant <script type="math/tex">t</script>.
They can simply encode a byte with a run-length of one which stores multiple transitions.
This leaves other areas which have very few transitions and can be encoded with longer runs.
Bitwise formats can not do this and need a separate marker for every single transition.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>It is not required for a RLE format to encode 8-bit values to take advantage of a higher <script type="math/tex">t_f</script>.
Any number of bits greater than one is sufficient.</p>
</div>
<h2 id="summary">Summary</h2>
<p>We compared <em>nested iteration</em>, <em>Z-Order Curves</em> and <em>Hilbert Curves</em> for use in RLE.
The impact of different space-filling curves was dramatic.
Bytewise formats such as <em>Complete Binvox</em> and <em>In-Band</em> performed worse with just nested iteration but saw
reductions in data of nearly 60% when using the latter methods.</p>
<p>Surprisingly, the previously better-performing bitwise formats did not see any benefit.
In fact, they became more redundant when using the latter space-filling curves.
This phenomenon was investigated and explained by demonstrating that only the number of transitions affects the number
of markers and thus the data size for bitwise formats.
In particular, <em>Z-Order Curves</em> negatively impact the number of transitions.</p>
<p>In total, we were able to achieve a reduction of 13% in data size using <em>Hilbert Curves</em> and <em>In-Band</em> over the
previously best method, <em>Compact Binvox</em> with <em>Nested Iteration</em>.
Unfortunately, the computational effort of <em>Hilbert Curves</em> puts into question whether a use of this method is
desired.</p>
              
            </div>
          </div>
<footer></footer>

        </div>
      </div>

    </section>

  </div>

  <div class="rst-versions" role="note" aria-label="versions">
    <span class="rst-current-version" data-toggle="rst-current-version">
      
      
        <span><a href="rle.html" style="color: #fcfcfc;">&laquo; Previous</a></span>
      
      
        <span style="margin-left: 15px"><a href="hilbert_curves.html" style="color: #fcfcfc">Next &raquo;</a></span>
      
    </span>
</div>
    <script>var base_url = '..';</script>
    <script src="../js/theme.js" defer></script>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS_HTML" defer></script>
      <script src="../js/mathjax_config.js" defer></script>
      <script src="../js/extra.js" defer></script>
      <script src="../search/main.js" defer></script>
    <script defer>
        window.onload = function () {
            SphinxRtdTheme.Navigation.enable(true);
        };
    </script>

</body>
</html>
